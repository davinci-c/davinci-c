/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package edu.davinci.lenguaje;

import java.text.MessageFormat;
import edu.davinci.utils.Resource;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants, ParserConstants {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

        public Node rootNode() {
        return jjtree.rootNode();
        }

        //**********************************************************************//
        //****************** METODOS HELPERS COMPILACION **********************//

    SymbolTable st_identificador = new SymbolTableImpl();
    SymbolTable st_subprograma   = new SymbolTableImpl();
    SymbolTable st_hilo          = new SymbolTableImpl();

    private String ambito="";
    private int definicion;

        /**
	* Retorna el ambito/contexto donde nos encontramos 
	*/
     String getAmbito(){
                return ambito;
        }

    /**
	*
	*/
     void setAmbito(String amb){
      ambito = amb;
    }

    /**
	*
	*/
     int getDefinicion(){
                return definicion;
        }

    /**
	*
	*/
     void setDefinicion(int def){
      definicion = def;
    }

        /**
	*
	*/
     public void verificarIdentificador(Token t)throws ParseException{
                //verificamos el ambito del identificador
            if(getDefinicion()==0){
                //se corresponde con un identificador global  
                if(!st_identificador.verificarDeclaracion(t.image))
                        //System.out.println(MessageFormat.format(Resource.getString("parser.identificadorNoDefinido"), id));
                                throw new ParseException(MessageFormat.format(Resource.getString("parser.identificador.desconocido"), t.image,t.beginLine,t.beginColumn));

            }else if(getDefinicion()== SUBPROGRAM){
                //se corresponde con un identificador de procedimiento
                String procedimiento = getAmbito();
                if(!st_subprograma.verificarDeclaracion(procedimiento, t.image))
                        //verificamos si esta definido como global
                        if(!st_identificador.verificarDeclaracion(t.image))
                                        throw new ParseException(MessageFormat.format(Resource.getString("parser.procedimiento.identificador.desconocido"),  t.image,t.beginLine,t.beginColumn));

            }else if(getDefinicion()==THREADS){
                //se corresponde con un identificador de hilo
                String hilo = getAmbito();
                if(!st_hilo.verificarDeclaracion(hilo, t.image))
                        //verificamos si esta definido como global
                        if(!st_identificador.verificarDeclaracion(t.image))
                                throw new ParseException(MessageFormat.format(Resource.getString("parser.hilo.identificador.desconocido"),  t.image,t.beginLine,t.beginColumn));

            }


        }

        /**
	*
	*/
     public void verificarSubprograma(Token identificador)throws ParseException{
                if(!st_subprograma.verificarDeclaracion(identificador.image))
                        throw new ParseException(MessageFormat.format(Resource.getString("parser.procedimiento.identificador.desconocido"), identificador.image, identificador.beginLine, identificador.beginColumn));
        }

        /**
	*
	*/
     public void verificarHilo(Token t)throws ParseException{

                if(!st_hilo.verificarDeclaracion(t.image))
                        throw new ParseException(MessageFormat.format(Resource.getString("parser.hilo.identificador.desconocido"),  t.image,t.beginLine,t.beginColumn));
                        //throw new ParseException(MessageFormat.format(Resource.getString("parser.hilo.identificador.desconocido"), id));
        }


        /**
	*
	*/
         public void insertarIdentificador(Token t, int type)throws ParseException{
           String id = t.image;
                //verificamos el ambito del identificador
                if(getDefinicion()==0){
                        //se corresponde con un identificador global  
                if(!st_identificador.agregarSimbolo(id, type))
                                throw new ParseException(MessageFormat.format(Resource.getString("parser.identificador.duplicado"), id,t.beginLine,t.beginColumn));

            }else if(getDefinicion()==SUBPROGRAM){
                //se corresponde con un identificador global
                String procedimiento = getAmbito();
                if(!st_subprograma.agregarSimbolo(procedimiento,id, type))
                  throw new ParseException(MessageFormat.format(Resource.getString("parser.procedimiento.identificador.duplicado"),procedimiento, id,t.beginLine,t.beginColumn));

            }else if(getDefinicion()==THREADS){
                String hilo = getAmbito();
                if(!st_hilo.agregarSimbolo(hilo, id, type))
                  throw new ParseException(MessageFormat.format(Resource.getString("parser.hilo.identificador.duplicado"), hilo,id,t.beginLine,t.beginColumn));
            }
        }

        /**
	*
	*/
        public void insertarSubprograma(Token t)throws ParseException{
           String id = t.image;
        if(!st_subprograma.agregarSimbolo(id, SUBPROGRAM))
                throw new ParseException(MessageFormat.format(Resource.getString("parser.identificador.duplicado"),id,t.beginLine,t.beginColumn));

        }

        public void insertarTipoFuncion(Token t, int type)throws ParseException{
           String id = t.image;
           st_subprograma.setTipo(id, type);
        }

        /**
	*
	*/
         public void insertarHilo(Token t)throws ParseException{
           String id = t.image;
        if(!st_hilo.agregarSimbolo(id, THREAD))
                throw new ParseException(MessageFormat.format(Resource.getString("parser.identificador.duplicado"),id,t.beginLine,t.beginColumn));

        }

        /**
	*
	*/
         public int obtenerTipo(Token t)throws ParseException{
                String id = t.image;
                //verificamos el ambito del identificador
                if(getDefinicion()==0){
                        //se corresponde con un identificador global  
                return st_identificador.getTipo(id);
            }else if(getDefinicion()==SUBPROGRAM){
                //se corresponde con un identificador de procedimiento
                String procedimiento = getAmbito();
                //verificamos si es global
                if(st_subprograma.getTipo(procedimiento, id)==0)
                                return st_identificador.getTipo(id);
                else
                        return st_subprograma.getTipo(procedimiento, id);
            }else if(getDefinicion()==THREADS){
                //se corresponde con un identificador de hilo
                String hilo = getAmbito();
                //verificamos si es global
                if(st_hilo.getTipo(hilo, id)==0)
                                return st_identificador.getTipo(id);
                else
                        return st_hilo.getTipo(hilo, id);
            }else
                        throw new ParseException(MessageFormat.format(Resource.getString("parser.identificador.incompatible"), id,t.beginLine,t.beginColumn));
        }

        public int obtenerTipoFuncion(Token t)throws ParseException{
                String id = t.image;

                //retornamos el tipo
                return st_subprograma.getTipo(id);
        }

        /**
	*
	*/
         public void verificarTipos(Token t,int tipoA, int tipoB)throws ParseException{
            //La verificacion de tipos del los semaforos es diferente al resto
                if (tipoB == SEMAPHORE){
                        if(tipoA != SEMAPHORE_BINARY && tipoA != SEMAPHORE_GENERAL)
                                throw new ParseException(MessageFormat.format(Resource.getString("parser.tipo.incompatible"), t.beginLine,t.beginColumn));
                }else{
                        //el resto de los tipos
                        if (tipoA!=tipoB)
                                throw new ParseException(MessageFormat.format(Resource.getString("parser.tipo.incompatible"), t.beginLine,t.beginColumn));
                                //System.out.println(MessageFormat.format(Resource.getString("parser.tiposDeDatoIncompatibles"), t.beginLine,t.beginColumn));

                }
        }

        /**
	*
	*/
         public void verificarTipos(Token t,int tipoA, int tipoB, int operador)throws ParseException{
                if (tipoA!=tipoB)
                                throw new ParseException(MessageFormat.format(Resource.getString("parser.tipo.incompatible"), t.beginLine,t.beginColumn));
        else{
          //Tipos coinciden, verificamos si tambien con el operador
          if((operador==EQ)|(operador==NE)){
                          if((tipoA==SEMAPHORE_BINARY)|(tipoA==SEMAPHORE_GENERAL))
                                        throw new ParseException(MessageFormat.format(Resource.getString("parser.tipo.incompatible"), t.beginLine,t.beginColumn));
                  }else if((operador==PLUS)|(operador==LE)|(operador==GT)){
                          if(tipoA==BOOLEAN)
                                        throw new ParseException(MessageFormat.format(Resource.getString("parser.tipo.incompatible"), t.beginLine,t.beginColumn));
                  }else if((operador==MINUS)|(operador==PROD)|(operador==DIV)|(operador==MOD)){
                          if((tipoA==BOOLEAN)|(tipoA==STRING))
                                        throw new ParseException(MessageFormat.format(Resource.getString("parser.tipo.incompatible"), t.beginLine,t.beginColumn));
                  }else if((operador==OR)|(operador==AND)){
                          if((tipoA==INTEGER)|(tipoA==STRING))
                                        throw new ParseException(MessageFormat.format(Resource.getString("parser.tipo.incompatible"), t.beginLine,t.beginColumn));
                  }
            }
        }


        //El padre lo da el ambito
         public void agregarParametroProcedimiento(Token t,int type, int input_output)throws ParseException{
            String id = t.image;
            String padre=getAmbito();
                try
                {
                    //establecemos si el parametro q agregamos es de salida
                    boolean esDeSalida=input_output==OUTPUT |input_output==INPUTOUTPUT;
                    st_subprograma.agregarParametro(padre,id,type,esDeSalida);
                }catch(Exception e){
                  throw new ParseException(MessageFormat.format(Resource.getString("parser.procedimiento.parametro.incompatible"), padre,id,t.beginLine,t.beginColumn));

                }
        }

         public void verificarParametroSubprograma(Token identificador,int type, int input_output, int order)throws ParseException{
           String nombre = identificador.image;
            //verificamos si el parametro con el q llamamos es de salida
            boolean esDeSalida=input_output==OUTPUT |input_output==INPUTOUTPUT;
            if(!st_subprograma.verificarParametro(nombre,type,esDeSalida,order))
                throw new ParseException(MessageFormat.format(Resource.getString("parser.procedimiento.argumento.incompatible"), identificador.beginLine,identificador.beginColumn));

        }

         public void verificarCantidadParametrosSubprograma(Token identificador,int cant)throws ParseException{
           String nombre = identificador.image;
            if(!st_subprograma.verificarCantidadDeParametros(nombre,cant))
                throw new ParseException(MessageFormat.format(Resource.getString("parser.procedimiento.parametro.cantidad.diferente"), identificador.beginLine,identificador.beginColumn));
        }

         public void agregarParametroHilo(Token t,int type)throws ParseException{
            String id = t.image;
                String padre=getAmbito();
                try
                {
                    //establecemos si el parametro q agregamos es de salida
                    boolean esDeSalida=false;
                    st_hilo.agregarParametro(padre,id,type,esDeSalida);
                }catch(Exception e){
                    throw new ParseException(MessageFormat.format(Resource.getString("parser.procedimiento.parametro.incompatible"), padre,id,t.beginLine,t.beginColumn));
                }
        }

         public void verificarParametroHilo(Token t,int type, int order)throws ParseException{
            //verificamos si el parametro con el q llamamos es de salida
            boolean esDeSalida=false;
            if(!st_hilo.verificarParametro(t.image,type,esDeSalida,order))
                throw new ParseException(MessageFormat.format(Resource.getString("parser.hilo.argumento.incompatible"), t.beginLine,t.beginColumn));

        }

         public void verificarCantidadParametrosHilo(Token t,int cant)throws ParseException{
            if(!st_hilo.verificarCantidadDeParametros(t.image,cant))
                throw new ParseException(MessageFormat.format(Resource.getString("parser.hilo.parametro.cantidad.diferente"), t.beginLine,t.beginColumn));

        }

//*****************************************************//
//*****************************************************//

//***********************//
  final public SimpleNode Compilar() throws ParseException {
    trace_call("Compilar");
    try {
                        /*@bgen(jjtree) Compilar */
  ASTCompilar jjtn000 = new ASTCompilar(JJTCOMPILAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
      try {
        jj_consume_token(PROGRAM);
        jj_consume_token(IDENTIFIER);
        Declaraciones();
        Cuerpo();
        jj_consume_token(0);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Compilar");
    }
  }

//**********************//
  final public void Declaraciones() throws ParseException {
    trace_call("Declaraciones");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VAR:
        Variables();
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUBPROGRAM:
        subprogramas();
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THREADS:
        Hilos();
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
   setDefinicion(0);setAmbito("");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VAR:
        Variables();
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
    } finally {
      trace_return("Declaraciones");
    }
  }

//**************//
  final public void Cuerpo() throws ParseException {
    trace_call("Cuerpo");
    try {
      jj_consume_token(BEGIN);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case WHILE:
        case REPEAT:
        case START:
        case MOVE:
        case RIGHT:
        case TAKEFLOWOR:
        case TAKEPAPER:
        case PUTFLOWER:
        case PUTPAPER:
        case MESSAGE:
        case READ:
        case POSITION:
        case THREAD_START:
        case SEMAPHORE_INIT:
        case SIGNAL:
        case WAIT:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_1;
        }
        Sentencia();
      }
      jj_consume_token(END);
    } finally {
      trace_return("Cuerpo");
    }
  }

//***************//
  final public void Hilos() throws ParseException {
    trace_call("Hilos");
    try {
      jj_consume_token(THREADS);
              setDefinicion(THREADS);
      label_2:
      while (true) {
        DefinicionHilo();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case THREAD:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_2;
        }
      }
    } finally {
      trace_return("Hilos");
    }
  }

//************************//
  final public void DefinicionHilo() throws ParseException {
    trace_call("DefinicionHilo");
    try {
 /*@bgen(jjtree) DefinicionHilo */
 ASTDefinicionHilo jjtn000 = new ASTDefinicionHilo(JJTDEFINICIONHILO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token identificador;
      try {
        jj_consume_token(THREAD);
        identificador = jj_consume_token(IDENTIFIER);
                                 insertarHilo(identificador);
                                 //seteamos el ambito para q cuando se definan variables o se usen sean del ambito del hilo
                                 setAmbito(identificador.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          ParametrosFormalesHilo();
          jj_consume_token(RPAREN);
          break;
        default:
          jj_la1[6] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR:
          Variables();
          break;
        default:
          jj_la1[7] = jj_gen;
          ;
        }
        Cuerpo();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    //Nombre del hilo
    jjtn000.nombre=identificador.image;
      } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
      } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtn000.jjtSetLastToken(getToken(0));
   }
      }
    } finally {
      trace_return("DefinicionHilo");
    }
  }

//************************//
  final public void ParametrosFormalesHilo() throws ParseException {
    trace_call("ParametrosFormalesHilo");
    try {
                                                       /*@bgen(jjtree) ParametrosFormalesHilo */
  ASTParametrosFormalesHilo jjtn000 = new ASTParametrosFormalesHilo(JJTPARAMETROSFORMALESHILO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
      try {
        ParametroFormalEntradaHilo();
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEMICOLON:
            ;
            break;
          default:
            jj_la1[8] = jj_gen;
            break label_3;
          }
          jj_consume_token(SEMICOLON);
          ParametroFormalEntradaHilo();
        }
      } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
      } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtn000.jjtSetLastToken(getToken(0));
     }
      }
    } finally {
      trace_return("ParametrosFormalesHilo");
    }
  }

//********************************************//
  final public void ParametroFormalEntradaHilo() throws ParseException {
    trace_call("ParametroFormalEntradaHilo");
    try {
 /*@bgen(jjtree) ParametroFormalEntradaHilo */
 ASTParametroFormalEntradaHilo jjtn000 = new ASTParametroFormalEntradaHilo(JJTPARAMETROFORMALENTRADAHILO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token identificador;
 int tipo;
      try {
        jj_consume_token(INPUT);
        identificador = jj_consume_token(IDENTIFIER);
        jj_consume_token(COLON);
        tipo = TipoPrimitivo();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    //insertamos el identificador y el tipo
    insertarIdentificador(identificador,tipo);

    //agregamos al padre el parametro
    agregarParametroHilo(identificador,tipo);

        //guardamos los datos del identificador
    jjtn000.nombre=identificador.image;
    jjtn000.tipo=tipo;
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("ParametroFormalEntradaHilo");
    }
  }

//***************//
  final public void subprogramas() throws ParseException {
    trace_call("subprogramas");
    try {
      jj_consume_token(SUBPROGRAM);
                 setDefinicion(SUBPROGRAM);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROCEDURE:
          DefinicionProcedimiento();
          break;
        case FUNCTION:
          DefinicionFuncion();
          break;
        default:
          jj_la1[9] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROCEDURE:
        case FUNCTION:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_4;
        }
      }
    } finally {
      trace_return("subprogramas");
    }
  }

//************************//
  final public void DefinicionProcedimiento() throws ParseException {
    trace_call("DefinicionProcedimiento");
    try {
 /*@bgen(jjtree) DefinicionProcedimiento */
 ASTDefinicionProcedimiento jjtn000 = new ASTDefinicionProcedimiento(JJTDEFINICIONPROCEDIMIENTO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token identificador;
      try {
        jj_consume_token(PROCEDURE);
        identificador = jj_consume_token(IDENTIFIER);
                                 //String nombreProcedimiento=t.image;
                                 insertarSubprograma(identificador);
                                 //seteamos el ambito para q cuando se definan variables o se usen sean del ambito del procedimiento
                                 setAmbito(identificador.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          ParametrosFormales();
          jj_consume_token(RPAREN);
          break;
        default:
          jj_la1[11] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR:
          Variables();
          break;
        default:
          jj_la1[12] = jj_gen;
          ;
        }
        Cuerpo();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.nombre=identificador.image;
      } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
      } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtn000.jjtSetLastToken(getToken(0));
   }
      }
    } finally {
      trace_return("DefinicionProcedimiento");
    }
  }

  final public void DefinicionFuncion() throws ParseException {
    trace_call("DefinicionFuncion");
    try {
 /*@bgen(jjtree) DefinicionFuncion */
 ASTDefinicionFuncion jjtn000 = new ASTDefinicionFuncion(JJTDEFINICIONFUNCION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token identificador;
int tipoF,tipoE;
      try {
        jj_consume_token(FUNCTION);
        identificador = jj_consume_token(IDENTIFIER);
                                 //
                                 insertarSubprograma(identificador);
                                 //seteamos el ambito para q cuando se definan variables o se usen sean del ambito de la funcion
                                 setAmbito(identificador.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          ParametrosFormales();
          jj_consume_token(RPAREN);
          break;
        default:
          jj_la1[13] = jj_gen;
          ;
        }
        jj_consume_token(COLON);
        tipoF = TipoPrimitivo();
                                 insertarTipoFuncion(identificador,tipoF);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR:
          Variables();
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
        jj_consume_token(BEGIN);
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IF:
          case WHILE:
          case REPEAT:
          case START:
          case MOVE:
          case RIGHT:
          case TAKEFLOWOR:
          case TAKEPAPER:
          case PUTFLOWER:
          case PUTPAPER:
          case MESSAGE:
          case READ:
          case POSITION:
          case THREAD_START:
          case SEMAPHORE_INIT:
          case SIGNAL:
          case WAIT:
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[15] = jj_gen;
            break label_5;
          }
          Sentencia();
        }
        jj_consume_token(RETURN);
                  ASTFuncionUsuarioRetorno jjtn001 = new ASTFuncionUsuarioRetorno(JJTFUNCIONUSUARIORETORNO);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtn001.jjtSetFirstToken(getToken(1));
        try {
          //
                          tipoE = Expresion();
        } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte001;}
                  }
                  if (jjte001 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte001;}
                  }
                  {if (true) throw (Error)jjte001;}
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtn001.jjtSetLastToken(getToken(0));
                  }
        }
                verificarTipos(token,tipoF,tipoE);
        jj_consume_token(END);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.nombre=identificador.image;
      } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
      } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtn000.jjtSetLastToken(getToken(0));
   }
      }
    } finally {
      trace_return("DefinicionFuncion");
    }
  }

//************************//
  final public void ParametrosFormales() throws ParseException {
    trace_call("ParametrosFormales");
    try {
                                               /*@bgen(jjtree) ParametrosFormales */
  ASTParametrosFormales jjtn000 = new ASTParametrosFormales(JJTPARAMETROSFORMALES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
      try {
        ParametroFormal();
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEMICOLON:
            ;
            break;
          default:
            jj_la1[16] = jj_gen;
            break label_6;
          }
          jj_consume_token(SEMICOLON);
          ParametroFormal();
        }
      } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
      } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtn000.jjtSetLastToken(getToken(0));
     }
      }
    } finally {
      trace_return("ParametrosFormales");
    }
  }

//*********************//
  final public void ParametroFormal() throws ParseException {
    trace_call("ParametroFormal");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INPUT:
        ParametroFormalEntrada();
        break;
      case OUTPUT:
        ParametroFormalSalida();
        break;
      case INPUTOUTPUT:
        ParametroFormalEntradaSalida();
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("ParametroFormal");
    }
  }

//********************************************//
  final public void ParametroFormalEntrada() throws ParseException {
    trace_call("ParametroFormalEntrada");
    try {
 /*@bgen(jjtree) ParametroFormalEntrada */
 ASTParametroFormalEntrada jjtn000 = new ASTParametroFormalEntrada(JJTPARAMETROFORMALENTRADA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token identificador;
 int tipo;
      try {
        jj_consume_token(INPUT);
        identificador = jj_consume_token(IDENTIFIER);
        jj_consume_token(COLON);
        tipo = TipoPrimitivo();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    //insertamos el identificador y el tipo
    insertarIdentificador(identificador,tipo);

    //agregamos al padre el parametro
    agregarParametroProcedimiento(identificador,tipo,INPUT);

        //guardamos los datos del identificador
    jjtn000.nombre=identificador.image;
    jjtn000.tipo=tipo;
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("ParametroFormalEntrada");
    }
  }

//*******************************************//
  final public void ParametroFormalSalida() throws ParseException {
    trace_call("ParametroFormalSalida");
    try {
 /*@bgen(jjtree) ParametroFormalSalida */
 ASTParametroFormalSalida jjtn000 = new ASTParametroFormalSalida(JJTPARAMETROFORMALSALIDA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token identificador;
 int tipo;
      try {
        jj_consume_token(OUTPUT);
        identificador = jj_consume_token(IDENTIFIER);
        jj_consume_token(COLON);
        tipo = TipoPrimitivo();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    //insertamos el identificador y el tipo
    insertarIdentificador(identificador,tipo);

    //agregamos al padre el parametro
    agregarParametroProcedimiento(identificador,tipo,OUTPUT);

        //guardamos los datos del identificador
    jjtn000.nombre=identificador.image;
    jjtn000.tipo=tipo;
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("ParametroFormalSalida");
    }
  }

//**************************************************//
  final public void ParametroFormalEntradaSalida() throws ParseException {
    trace_call("ParametroFormalEntradaSalida");
    try {
 /*@bgen(jjtree) ParametroFormalEntradaSalida */
 ASTParametroFormalEntradaSalida jjtn000 = new ASTParametroFormalEntradaSalida(JJTPARAMETROFORMALENTRADASALIDA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token identificador;
 int tipo;
      try {
        jj_consume_token(INPUTOUTPUT);
        identificador = jj_consume_token(IDENTIFIER);
        jj_consume_token(COLON);
        tipo = TipoPrimitivo();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    //insertamos el identificador y el tipo
    insertarIdentificador(identificador,tipo);

    //agregamos al padre el parametro
    agregarParametroProcedimiento(identificador,tipo,INPUTOUTPUT);

        //guardamos los datos del identificador
    jjtn000.nombre=identificador.image;
    jjtn000.tipo=tipo;
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("ParametroFormalEntradaSalida");
    }
  }

//***************//
  final public void Variables() throws ParseException {
    trace_call("Variables");
    try {
      jj_consume_token(VAR);
      label_7:
      while (true) {
        DefinicionVariable();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_7;
        }
      }
    } finally {
      trace_return("Variables");
    }
  }

//************************//
  final public void DefinicionVariable() throws ParseException {
    trace_call("DefinicionVariable");
    try {
 /*@bgen(jjtree) DefinicionVariable */
  ASTDefinicionVariable jjtn000 = new ASTDefinicionVariable(JJTDEFINICIONVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token identificador; int tipo;
      try {
        identificador = jj_consume_token(IDENTIFIER);
                  jjtn000.setNombre(identificador.image);
        jj_consume_token(COLON);
        tipo = TipoPrimitivo();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtn000.jjtSetLastToken(getToken(0));
        insertarIdentificador(identificador,tipo);
        jjtn000.tipo=tipo;
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("DefinicionVariable");
    }
  }

  final public int TipoPrimitivo() throws ParseException {
    trace_call("TipoPrimitivo");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        jj_consume_token(INTEGER);
        break;
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
        break;
      case STRING:
        jj_consume_token(STRING);
        break;
      case SEMAPHORE_BINARY:
        jj_consume_token(SEMAPHORE_BINARY);
        break;
      case SEMAPHORE_GENERAL:
        jj_consume_token(SEMAPHORE_GENERAL);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
       {if (true) return token.kind;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TipoPrimitivo");
    }
  }

//***************//
  final public void Sentencia() throws ParseException {
    trace_call("Sentencia");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START:
      case MOVE:
      case RIGHT:
      case TAKEFLOWOR:
      case TAKEPAPER:
      case PUTFLOWER:
      case PUTPAPER:
        Primitiva();
        break;
      case MESSAGE:
      case READ:
      case POSITION:
      case THREAD_START:
      case SEMAPHORE_INIT:
      case SIGNAL:
      case WAIT:
      case IDENTIFIER:
        SentenciaSimple();
        break;
      case IF:
      case WHILE:
      case REPEAT:
        SentenciaCompuesta();
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Sentencia");
    }
  }

//***************//
  final public void Primitiva() throws ParseException {
    trace_call("Primitiva");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START:
    ASTPri_Iniciar jjtn001 = new ASTPri_Iniciar(JJTPRI_INICIAR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtn001.jjtSetFirstToken(getToken(1));
        try {
          jj_consume_token(START);
        } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      jjtn001.jjtSetLastToken(getToken(0));
    }
        }
        break;
      case MOVE:
    ASTPri_Mover jjtn002 = new ASTPri_Mover(JJTPRI_MOVER);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtn002.jjtSetFirstToken(getToken(1));
        try {
          jj_consume_token(MOVE);
        } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
      jjtn002.jjtSetLastToken(getToken(0));
    }
        }
        break;
      case RIGHT:
    ASTPri_Derecha jjtn003 = new ASTPri_Derecha(JJTPRI_DERECHA);
    boolean jjtc003 = true;
    jjtree.openNodeScope(jjtn003);
    jjtn003.jjtSetFirstToken(getToken(1));
        try {
          jj_consume_token(RIGHT);
        } finally {
    if (jjtc003) {
      jjtree.closeNodeScope(jjtn003, true);
      jjtn003.jjtSetLastToken(getToken(0));
    }
        }
        break;
      case TAKEFLOWOR:
    ASTPri_TomarFlor jjtn004 = new ASTPri_TomarFlor(JJTPRI_TOMARFLOR);
    boolean jjtc004 = true;
    jjtree.openNodeScope(jjtn004);
    jjtn004.jjtSetFirstToken(getToken(1));
        try {
          jj_consume_token(TAKEFLOWOR);
        } finally {
    if (jjtc004) {
      jjtree.closeNodeScope(jjtn004, true);
      jjtn004.jjtSetLastToken(getToken(0));
    }
        }
        break;
      case TAKEPAPER:
    ASTPri_TomarPapel jjtn005 = new ASTPri_TomarPapel(JJTPRI_TOMARPAPEL);
    boolean jjtc005 = true;
    jjtree.openNodeScope(jjtn005);
    jjtn005.jjtSetFirstToken(getToken(1));
        try {
          jj_consume_token(TAKEPAPER);
        } finally {
    if (jjtc005) {
      jjtree.closeNodeScope(jjtn005, true);
      jjtn005.jjtSetLastToken(getToken(0));
    }
        }
        break;
      case PUTFLOWER:
    ASTPri_DepositarFlor jjtn006 = new ASTPri_DepositarFlor(JJTPRI_DEPOSITARFLOR);
    boolean jjtc006 = true;
    jjtree.openNodeScope(jjtn006);
    jjtn006.jjtSetFirstToken(getToken(1));
        try {
          jj_consume_token(PUTFLOWER);
        } finally {
    if (jjtc006) {
      jjtree.closeNodeScope(jjtn006, true);
      jjtn006.jjtSetLastToken(getToken(0));
    }
        }
        break;
      case PUTPAPER:
    ASTPri_DepositarPapel jjtn007 = new ASTPri_DepositarPapel(JJTPRI_DEPOSITARPAPEL);
    boolean jjtc007 = true;
    jjtree.openNodeScope(jjtn007);
    jjtn007.jjtSetFirstToken(getToken(1));
        try {
          jj_consume_token(PUTPAPER);
        } finally {
    if (jjtc007) {
      jjtree.closeNodeScope(jjtn007, true);
      jjtn007.jjtSetLastToken(getToken(0));
    }
        }
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Primitiva");
    }
  }

//*********************//
  final public void SentenciaSimple() throws ParseException {
    trace_call("SentenciaSimple");
    try {
      if (jj_2_1(2)) {
        Asignacion();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MESSAGE:
        case READ:
        case POSITION:
        case THREAD_START:
        case SEMAPHORE_INIT:
        case SIGNAL:
        case WAIT:
        case IDENTIFIER:
          Invocacion();
          break;
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
      trace_return("SentenciaSimple");
    }
  }

//****************//
  final public void Asignacion() throws ParseException {
    trace_call("Asignacion");
    try {
 /*@bgen(jjtree) #Asignacion( 2) */
 ASTAsignacion jjtn000 = new ASTAsignacion(JJTASIGNACION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipoI,tipoE;
      try {
        tipoI = Identificador();
        jj_consume_token(ASSIGN);
        tipoE = Expresion();
    jjtree.closeNodeScope(jjtn000,  2);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
   verificarTipos(token,tipoI,tipoE);
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  2);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("Asignacion");
    }
  }

//*******************//
  final public int Identificador() throws ParseException {
    trace_call("Identificador");
    try {
 /*@bgen(jjtree) Identificador */
 ASTIdentificador jjtn000 = new ASTIdentificador(JJTIDENTIFICADOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token identificador;
      try {
        identificador = jj_consume_token(IDENTIFIER);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          //verificamos que exista
          verificarIdentificador(identificador);

          //guardamos el nombre del identificador
          jjtn000.setNombre(identificador.image);

          //retornamos el tipo del identificador
          {if (true) return obtenerTipo(identificador);}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Identificador");
    }
  }

  final public int FuncionUsuario() throws ParseException {
    trace_call("FuncionUsuario");
    try {
 /*@bgen(jjtree) FuncionUsuario */
 ASTFuncionUsuario jjtn000 = new ASTFuncionUsuario(JJTFUNCIONUSUARIO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token identificador;int tipo;int orden=0;int kind;
      try {
        identificador = jj_consume_token(IDENTIFIER);
                    //verificamos que exista
                    verificarSubprograma(identificador);
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TRUE:
        case FALSE:
        case POSAV:
        case POSCA:
        case HAYFLORENLAESQUINA:
        case HAYFLORENLABOLSA:
        case HAYPAPELENLAESQUINA:
        case HAYPAPELENLABOLSA:
        case HAYOBSTACULO:
        case HAYROBOT:
        case RANDOM:
        case LENGTH:
        case SUBSTRING:
        case NUMBERTOTEXT:
        case TEXTTONUMBER:
        case LOGICTOTEXT:
        case LOWERCASE:
        case UPPERCASE:
        case TRIM:
        case REPLACE:
        case STARTSWITH:
        case ENDSWITH:
        case INDEXOF:
        case SQRT:
        case POW:
        case MAX:
        case SIN:
        case COS:
        case TAN:
        case LOG:
        case RANDOMLET:
        case INTEGER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case NOT:
        case PLUS:
        case MINUS:
          if (jj_2_2(2147483647)) {
            tipo = Identificador();
                                      kind=OUTPUT;
                                      jjtn000.addNombreParametrosReales(token.image);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case TRUE:
            case FALSE:
            case POSAV:
            case POSCA:
            case HAYFLORENLAESQUINA:
            case HAYFLORENLABOLSA:
            case HAYPAPELENLAESQUINA:
            case HAYPAPELENLABOLSA:
            case HAYOBSTACULO:
            case HAYROBOT:
            case RANDOM:
            case LENGTH:
            case SUBSTRING:
            case NUMBERTOTEXT:
            case TEXTTONUMBER:
            case LOGICTOTEXT:
            case LOWERCASE:
            case UPPERCASE:
            case TRIM:
            case REPLACE:
            case STARTSWITH:
            case ENDSWITH:
            case INDEXOF:
            case SQRT:
            case POW:
            case MAX:
            case SIN:
            case COS:
            case TAN:
            case LOG:
            case RANDOMLET:
            case INTEGER_LITERAL:
            case STRING_LITERAL:
            case IDENTIFIER:
            case LPAREN:
            case NOT:
            case PLUS:
            case MINUS:
              tipo = Expresion();
                                              kind=INPUT;
                                              jjtn000.addNombreParametrosReales(null);
              break;
            default:
              jj_la1[23] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
                      verificarParametroSubprograma(identificador,tipo,kind,orden++);
          label_8:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[24] = jj_gen;
              break label_8;
            }
            jj_consume_token(COMMA);
            if (jj_2_3(2147483647)) {
              tipo = Identificador();
                                      kind=OUTPUT;
                                      jjtn000.addNombreParametrosReales(token.image);
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case TRUE:
              case FALSE:
              case POSAV:
              case POSCA:
              case HAYFLORENLAESQUINA:
              case HAYFLORENLABOLSA:
              case HAYPAPELENLAESQUINA:
              case HAYPAPELENLABOLSA:
              case HAYOBSTACULO:
              case HAYROBOT:
              case RANDOM:
              case LENGTH:
              case SUBSTRING:
              case NUMBERTOTEXT:
              case TEXTTONUMBER:
              case LOGICTOTEXT:
              case LOWERCASE:
              case UPPERCASE:
              case TRIM:
              case REPLACE:
              case STARTSWITH:
              case ENDSWITH:
              case INDEXOF:
              case SQRT:
              case POW:
              case MAX:
              case SIN:
              case COS:
              case TAN:
              case LOG:
              case RANDOMLET:
              case INTEGER_LITERAL:
              case STRING_LITERAL:
              case IDENTIFIER:
              case LPAREN:
              case NOT:
              case PLUS:
              case MINUS:
                tipo = Expresion();
                                              kind=INPUT;
                                              jjtn000.addNombreParametrosReales(null);
                break;
              default:
                jj_la1[25] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
                          verificarParametroSubprograma(identificador,tipo,kind,orden++);
          }
          break;
        default:
          jj_la1[26] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
              jjtn000.jjtSetLastToken(getToken(0));
              //como los parametros son opcionales en la definicion es necesario reconocer la cantidad
              verificarCantidadParametrosSubprograma(identificador, orden);

              //nombre del procedimiento
              jjtn000.setNombre(identificador.image);

              {if (true) return obtenerTipoFuncion(identificador);}
      } catch (Throwable jjte000) {
              if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte000 instanceof RuntimeException) {
                {if (true) throw (RuntimeException)jjte000;}
              }
              if (jjte000 instanceof ParseException) {
                {if (true) throw (ParseException)jjte000;}
              }
              {if (true) throw (Error)jjte000;}
      } finally {
              if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
                jjtn000.jjtSetLastToken(getToken(0));
              }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FuncionUsuario");
    }
  }

//***************//
  final public int Expresion() throws ParseException {
    trace_call("Expresion");
    try {
 /*@bgen(jjtree) Expresion */
 ASTExpresion jjtn000 = new ASTExpresion(JJTEXPRESION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
 int tipoRela;
 int operador;
      try {
        tipo = ExpresionSimple();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQ:
        case LE:
        case GT:
        case LT:
        case GE:
        case NE:
          operador = OperadorRelacional();
                                      ASTOperacionRel jjtn001 = new ASTOperacionRel(JJTOPERACIONREL);
                                      boolean jjtc001 = true;
                                      jjtree.openNodeScope(jjtn001);
                                      jjtn001.jjtSetFirstToken(getToken(1));
          try {
            tipoRela = ExpresionSimple();
          } catch (Throwable jjte001) {
                                      if (jjtc001) {
                                        jjtree.clearNodeScope(jjtn001);
                                        jjtc001 = false;
                                      } else {
                                        jjtree.popNode();
                                      }
                                      if (jjte001 instanceof RuntimeException) {
                                        {if (true) throw (RuntimeException)jjte001;}
                                      }
                                      if (jjte001 instanceof ParseException) {
                                        {if (true) throw (ParseException)jjte001;}
                                      }
                                      {if (true) throw (Error)jjte001;}
          } finally {
                                      if (jjtc001) {
                                        jjtree.closeNodeScope(jjtn001,  3);
                                        jjtn001.jjtSetLastToken(getToken(0));
                                      }
          }
        verificarTipos(token,tipo,tipoRela,operador);
        tipo=BOOLEAN;
          break;
        default:
          jj_la1[27] = jj_gen;
          ;
        }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtn000.jjtSetLastToken(getToken(0));
  {if (true) return tipo;}
      } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
      } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtn000.jjtSetLastToken(getToken(0));
   }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Expresion");
    }
  }

//*********************//
  final public int ExpresionSimple() throws ParseException {
    trace_call("ExpresionSimple");
    try {
 int tipo;
 int tipoSum;
 int operador;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        tipo = SignoTermino();
        break;
      case TRUE:
      case FALSE:
      case POSAV:
      case POSCA:
      case HAYFLORENLAESQUINA:
      case HAYFLORENLABOLSA:
      case HAYPAPELENLAESQUINA:
      case HAYPAPELENLABOLSA:
      case HAYOBSTACULO:
      case HAYROBOT:
      case RANDOM:
      case LENGTH:
      case SUBSTRING:
      case NUMBERTOTEXT:
      case TEXTTONUMBER:
      case LOGICTOTEXT:
      case LOWERCASE:
      case UPPERCASE:
      case TRIM:
      case REPLACE:
      case STARTSWITH:
      case ENDSWITH:
      case INDEXOF:
      case SQRT:
      case POW:
      case MAX:
      case SIN:
      case COS:
      case TAN:
      case LOG:
      case RANDOMLET:
      case INTEGER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case NOT:
        tipo = Termino();
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
        case PLUS:
        case MINUS:
          ;
          break;
        default:
          jj_la1[29] = jj_gen;
          break label_9;
        }
        operador = OperadorAditivo();
                                     ASTOperacionSum jjtn001 = new ASTOperacionSum(JJTOPERACIONSUM);
                                     boolean jjtc001 = true;
                                     jjtree.openNodeScope(jjtn001);
                                     jjtn001.jjtSetFirstToken(getToken(1));
        try {
          tipoSum = Termino();
        } catch (Throwable jjte001) {
                                     if (jjtc001) {
                                       jjtree.clearNodeScope(jjtn001);
                                       jjtc001 = false;
                                     } else {
                                       jjtree.popNode();
                                     }
                                     if (jjte001 instanceof RuntimeException) {
                                       {if (true) throw (RuntimeException)jjte001;}
                                     }
                                     if (jjte001 instanceof ParseException) {
                                       {if (true) throw (ParseException)jjte001;}
                                     }
                                     {if (true) throw (Error)jjte001;}
        } finally {
                                     if (jjtc001) {
                                       jjtree.closeNodeScope(jjtn001,  3);
                                       jjtn001.jjtSetLastToken(getToken(0));
                                     }
        }
                                                                      verificarTipos(token,tipo,tipoSum,operador);
      }
    {if (true) return tipo;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExpresionSimple");
    }
  }

//*************//
  final public int Termino() throws ParseException {
    trace_call("Termino");
    try {
 int tipo;
 int tipoMult;
 int operador;
      tipo = Factor();
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
        case PROD:
        case DIV:
        case MOD:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_10;
        }
        operador = OperadorMultiplicativo();
                                       ASTOperacionMul jjtn001 = new ASTOperacionMul(JJTOPERACIONMUL);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
                                       jjtn001.jjtSetFirstToken(getToken(1));
        try {
          tipoMult = Factor();
        } catch (Throwable jjte001) {
                                       if (jjtc001) {
                                         jjtree.clearNodeScope(jjtn001);
                                         jjtc001 = false;
                                       } else {
                                         jjtree.popNode();
                                       }
                                       if (jjte001 instanceof RuntimeException) {
                                         {if (true) throw (RuntimeException)jjte001;}
                                       }
                                       if (jjte001 instanceof ParseException) {
                                         {if (true) throw (ParseException)jjte001;}
                                       }
                                       {if (true) throw (Error)jjte001;}
        } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  3);
                                         jjtn001.jjtSetLastToken(getToken(0));
                                       }
        }
                                                                       verificarTipos(token,tipo,tipoMult,operador);
      }
   {if (true) return tipo;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Termino");
    }
  }

//******************//
  final public int Factor() throws ParseException {
    trace_call("Factor");
    try {
 int tipo;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        if (jj_2_4(2)) {
          tipo = FuncionUsuario();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            tipo = Identificador();
            break;
          default:
            jj_la1[31] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      case TRUE:
      case FALSE:
      case INTEGER_LITERAL:
      case STRING_LITERAL:
        tipo = Constante();
        break;
      case POSAV:
      case POSCA:
      case HAYFLORENLAESQUINA:
      case HAYFLORENLABOLSA:
      case HAYPAPELENLAESQUINA:
      case HAYPAPELENLABOLSA:
      case HAYOBSTACULO:
        tipo = VariablePrimitiva();
        break;
      case HAYROBOT:
      case RANDOM:
      case LENGTH:
      case SUBSTRING:
      case NUMBERTOTEXT:
      case TEXTTONUMBER:
      case LOGICTOTEXT:
      case LOWERCASE:
      case UPPERCASE:
      case TRIM:
      case REPLACE:
      case STARTSWITH:
      case ENDSWITH:
      case INDEXOF:
      case SQRT:
      case POW:
      case MAX:
      case SIN:
      case COS:
      case TAN:
      case LOG:
      case RANDOMLET:
        tipo = FuncionPrimitiva();
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        tipo = Expresion();
        jj_consume_token(RPAREN);
        break;
      case NOT:
        jj_consume_token(NOT);
                     ASTOperacionNeg jjtn001 = new ASTOperacionNeg(JJTOPERACIONNEG);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
                     jjtn001.jjtSetFirstToken(getToken(1));
        try {
          tipo = Factor();
        } catch (Throwable jjte001) {
                     if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte001 instanceof RuntimeException) {
                       {if (true) throw (RuntimeException)jjte001;}
                     }
                     if (jjte001 instanceof ParseException) {
                       {if (true) throw (ParseException)jjte001;}
                     }
                     {if (true) throw (Error)jjte001;}
        } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001, true);
                       jjtn001.jjtSetLastToken(getToken(0));
                     }
        }
        break;
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         {if (true) return tipo;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Factor");
    }
  }

//*****************************//
  final public int FuncionPrimitiva() throws ParseException {
    trace_call("FuncionPrimitiva");
    try {
 int tipo;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RANDOM:
        tipo = Aleatorio();
        break;
      case LENGTH:
        tipo = Longitud();
        break;
      case SUBSTRING:
        tipo = Sustraer();
        break;
      case NUMBERTOTEXT:
        tipo = NumeroATexto();
        break;
      case TEXTTONUMBER:
        tipo = TextoANumero();
        break;
      case LOGICTOTEXT:
        tipo = LogicoATexto();
        break;
      case HAYROBOT:
        tipo = HayRobot();
        break;
      case LOWERCASE:
        tipo = Minuscula();
        break;
      case UPPERCASE:
        tipo = Mayuscula();
        break;
      case TRIM:
        tipo = Cortar();
        break;
      case REPLACE:
        tipo = Reemplazar();
        break;
      case STARTSWITH:
        tipo = Comienzacon();
        break;
      case ENDSWITH:
        tipo = Terminacon();
        break;
      case INDEXOF:
        tipo = Indicede();
        break;
      case SQRT:
        tipo = Raiz();
        break;
      case POW:
        tipo = Potencia();
        break;
      case MAX:
        tipo = MayorValor();
        break;
      case SIN:
        tipo = Seno();
        break;
      case COS:
        tipo = Coseno();
        break;
      case TAN:
        tipo = Tangente();
        break;
      case LOG:
        tipo = Logaritmo();
        break;
      case RANDOMLET:
        tipo = LetraAleatoria();
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   {if (true) return tipo;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FuncionPrimitiva");
    }
  }

//*****************************//
  final public int Aleatorio() throws ParseException {
    trace_call("Aleatorio");
    try {
 /*@bgen(jjtree) FunPri_Aleatorio */
 ASTFunPri_Aleatorio jjtn000 = new ASTFunPri_Aleatorio(JJTFUNPRI_ALEATORIO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(RANDOM);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,INTEGER);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return INTEGER;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Aleatorio");
    }
  }

//*****************************//
  final public int Minuscula() throws ParseException {
    trace_call("Minuscula");
    try {
 /*@bgen(jjtree) FunPri_Minuscula */
 ASTFunPri_Minuscula jjtn000 = new ASTFunPri_Minuscula(JJTFUNPRI_MINUSCULA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(LOWERCASE);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return STRING;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Minuscula");
    }
  }

//*****************************//
  final public int Mayuscula() throws ParseException {
    trace_call("Mayuscula");
    try {
 /*@bgen(jjtree) FunPri_Mayuscula */
 ASTFunPri_Mayuscula jjtn000 = new ASTFunPri_Mayuscula(JJTFUNPRI_MAYUSCULA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(UPPERCASE);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return STRING;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Mayuscula");
    }
  }

//*****************************//
  final public int Cortar() throws ParseException {
    trace_call("Cortar");
    try {
 /*@bgen(jjtree) FunPri_Cortar */
 ASTFunPri_Cortar jjtn000 = new ASTFunPri_Cortar(JJTFUNPRI_CORTAR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(TRIM);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return STRING;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Cortar");
    }
  }

//*****************************//
  final public int Reemplazar() throws ParseException {
    trace_call("Reemplazar");
    try {
 /*@bgen(jjtree) FunPri_Reemplazar */
 ASTFunPri_Reemplazar jjtn000 = new ASTFunPri_Reemplazar(JJTFUNPRI_REEMPLAZAR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(REPLACE);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(COMMA);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(COMMA);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return STRING;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Reemplazar");
    }
  }

//*****************************//
  final public int Comienzacon() throws ParseException {
    trace_call("Comienzacon");
    try {
 /*@bgen(jjtree) FunPri_Comienzacon */
 ASTFunPri_Comienzacon jjtn000 = new ASTFunPri_Comienzacon(JJTFUNPRI_COMIENZACON);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(STARTSWITH);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(COMMA);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return BOOLEAN;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Comienzacon");
    }
  }

//*****************************//
  final public int Terminacon() throws ParseException {
    trace_call("Terminacon");
    try {
 /*@bgen(jjtree) FunPri_Terminacon */
 ASTFunPri_Terminacon jjtn000 = new ASTFunPri_Terminacon(JJTFUNPRI_TERMINACON);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(ENDSWITH);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(COMMA);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return BOOLEAN;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Terminacon");
    }
  }

//*****************************//
  final public int Indicede() throws ParseException {
    trace_call("Indicede");
    try {
 /*@bgen(jjtree) FunPri_Indicede */
 ASTFunPri_Indicede jjtn000 = new ASTFunPri_Indicede(JJTFUNPRI_INDICEDE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(INDEXOF);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(COMMA);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return INTEGER;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Indicede");
    }
  }

  final public int Raiz() throws ParseException {
    trace_call("Raiz");
    try {
 /*@bgen(jjtree) FunPri_Raiz */
 ASTFunPri_Raiz jjtn000 = new ASTFunPri_Raiz(JJTFUNPRI_RAIZ);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(SQRT);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,INTEGER);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return INTEGER;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Raiz");
    }
  }

  final public int Potencia() throws ParseException {
    trace_call("Potencia");
    try {
 /*@bgen(jjtree) FunPri_Potencia */
 ASTFunPri_Potencia jjtn000 = new ASTFunPri_Potencia(JJTFUNPRI_POTENCIA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(POW);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                      verificarTipos(token,tipo,INTEGER);
        jj_consume_token(COMMA);
        tipo = Expresion();
                                      verificarTipos(token,tipo,INTEGER);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return INTEGER;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Potencia");
    }
  }

  final public int MayorValor() throws ParseException {
    trace_call("MayorValor");
    try {
 /*@bgen(jjtree) FunPri_MayorValor */
 ASTFunPri_MayorValor jjtn000 = new ASTFunPri_MayorValor(JJTFUNPRI_MAYORVALOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(MAX);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                      verificarTipos(token,tipo,INTEGER);
        jj_consume_token(COMMA);
        tipo = Expresion();
                                      verificarTipos(token,tipo,INTEGER);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return INTEGER;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MayorValor");
    }
  }

  final public int Seno() throws ParseException {
    trace_call("Seno");
    try {
 /*@bgen(jjtree) FunPri_Seno */
 ASTFunPri_Seno jjtn000 = new ASTFunPri_Seno(JJTFUNPRI_SENO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(SIN);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,INTEGER);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return INTEGER;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Seno");
    }
  }

  final public int Coseno() throws ParseException {
    trace_call("Coseno");
    try {
 /*@bgen(jjtree) FunPri_Coseno */
 ASTFunPri_Coseno jjtn000 = new ASTFunPri_Coseno(JJTFUNPRI_COSENO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(COS);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,INTEGER);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return INTEGER;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Coseno");
    }
  }

  final public int Tangente() throws ParseException {
    trace_call("Tangente");
    try {
 /*@bgen(jjtree) FunPri_Tangente */
 ASTFunPri_Tangente jjtn000 = new ASTFunPri_Tangente(JJTFUNPRI_TANGENTE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(TAN);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,INTEGER);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return INTEGER;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Tangente");
    }
  }

  final public int Logaritmo() throws ParseException {
    trace_call("Logaritmo");
    try {
 /*@bgen(jjtree) FunPri_Logaritmo */
 ASTFunPri_Logaritmo jjtn000 = new ASTFunPri_Logaritmo(JJTFUNPRI_LOGARITMO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(LOG);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,INTEGER);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return INTEGER;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Logaritmo");
    }
  }

  final public int LetraAleatoria() throws ParseException {
    trace_call("LetraAleatoria");
    try {
 /*@bgen(jjtree) FunPri_LetraAleatoria */
 ASTFunPri_LetraAleatoria jjtn000 = new ASTFunPri_LetraAleatoria(JJTFUNPRI_LETRAALEATORIA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(RANDOMLET);
        jj_consume_token(LPAREN);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return STRING;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LetraAleatoria");
    }
  }

//*****************************//
  final public int Longitud() throws ParseException {
    trace_call("Longitud");
    try {
 /*@bgen(jjtree) FunPri_Longitud */
 ASTFunPri_Longitud jjtn000 = new ASTFunPri_Longitud(JJTFUNPRI_LONGITUD);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(LENGTH);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return INTEGER;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Longitud");
    }
  }

//*****************************//
  final public int Sustraer() throws ParseException {
    trace_call("Sustraer");
    try {
 /*@bgen(jjtree) FunPri_Sustraer */
 ASTFunPri_Sustraer jjtn000 = new ASTFunPri_Sustraer(JJTFUNPRI_SUSTRAER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(SUBSTRING);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(COMMA);
        tipo = Expresion();
                                          verificarTipos(token,tipo,INTEGER);
        jj_consume_token(COMMA);
        tipo = Expresion();
                                          verificarTipos(token,tipo,INTEGER);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return STRING;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Sustraer");
    }
  }

//************************************//
  final public int NumeroATexto() throws ParseException {
    trace_call("NumeroATexto");
    try {
 /*@bgen(jjtree) FunPri_NumeroATexto */
 ASTFunPri_NumeroATexto jjtn000 = new ASTFunPri_NumeroATexto(JJTFUNPRI_NUMEROATEXTO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(NUMBERTOTEXT);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,INTEGER);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return STRING;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NumeroATexto");
    }
  }

//************************************//
  final public int TextoANumero() throws ParseException {
    trace_call("TextoANumero");
    try {
 /*@bgen(jjtree) FunPri_TextoANumero */
 ASTFunPri_TextoANumero jjtn000 = new ASTFunPri_TextoANumero(JJTFUNPRI_TEXTOANUMERO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(TEXTTONUMBER);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,STRING);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return INTEGER;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TextoANumero");
    }
  }

//************************************//
  final public int LogicoATexto() throws ParseException {
    trace_call("LogicoATexto");
    try {
 /*@bgen(jjtree) FunPri_LogicoATexto */
 ASTFunPri_LogicoATexto jjtn000 = new ASTFunPri_LogicoATexto(JJTFUNPRI_LOGICOATEXTO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(LOGICTOTEXT);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                          verificarTipos(token,tipo,BOOLEAN);
        jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return STRING;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LogicoATexto");
    }
  }

//************************************//
  final public int HayRobot() throws ParseException {
    trace_call("HayRobot");
    try {
 /*@bgen(jjtree) FunPri_HayRobot */
 ASTFunPri_HayRobot jjtn000 = new ASTFunPri_HayRobot(JJTFUNPRI_HAYROBOT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(HAYROBOT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          tipo = Expresion();
                                          verificarTipos(token,tipo,INTEGER);
          jj_consume_token(COMMA);
          tipo = Expresion();
                                          verificarTipos(token,tipo,INTEGER);
          jj_consume_token(RPAREN);
          break;
        default:
          jj_la1[34] = jj_gen;
          ;
        }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.jjtSetLastToken(getToken(0));
          {if (true) return BOOLEAN;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("HayRobot");
    }
  }

//***********************//
  final public int VariablePrimitiva() throws ParseException {
    trace_call("VariablePrimitiva");
    try {
 /*@bgen(jjtree) Pri_Variable */
 ASTPri_Variable jjtn000 = new ASTPri_Variable(JJTPRI_VARIABLE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case POSAV:
          jj_consume_token(POSAV);
                                         tipo=INTEGER;
          break;
        case POSCA:
          jj_consume_token(POSCA);
                                         tipo=INTEGER;
          break;
        case HAYFLORENLAESQUINA:
          jj_consume_token(HAYFLORENLAESQUINA);
                                         tipo=BOOLEAN;
          break;
        case HAYFLORENLABOLSA:
          jj_consume_token(HAYFLORENLABOLSA);
                                         tipo=BOOLEAN;
          break;
        case HAYPAPELENLAESQUINA:
          jj_consume_token(HAYPAPELENLAESQUINA);
                                         tipo=BOOLEAN;
          break;
        case HAYPAPELENLABOLSA:
          jj_consume_token(HAYPAPELENLABOLSA);
                                         tipo=BOOLEAN;
          break;
        case HAYOBSTACULO:
          jj_consume_token(HAYOBSTACULO);
                                         tipo=BOOLEAN;
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.nombre=token.image;
        {if (true) return tipo;}
      } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtn000.jjtSetLastToken(getToken(0));
   }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("VariablePrimitiva");
    }
  }

//*********************//
  final public int OperadorAditivo() throws ParseException {
    trace_call("OperadorAditivo");
    try {
                       /*@bgen(jjtree) OperadorAditivo */
  ASTOperadorAditivo jjtn000 = new ASTOperadorAditivo(JJTOPERADORADITIVO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          break;
        case MINUS:
          jj_consume_token(MINUS);
          break;
        case OR:
          jj_consume_token(OR);
          break;
        default:
          jj_la1[36] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.operador = token.image;
    {if (true) return token.kind;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("OperadorAditivo");
    }
  }

//****************************//
  final public int OperadorMultiplicativo() throws ParseException {
    trace_call("OperadorMultiplicativo");
    try {
                              /*@bgen(jjtree) OperadorMultiplicativo */
  ASTOperadorMultiplicativo jjtn000 = new ASTOperadorMultiplicativo(JJTOPERADORMULTIPLICATIVO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROD:
          jj_consume_token(PROD);
          break;
        case DIV:
          jj_consume_token(DIV);
          break;
        case AND:
          jj_consume_token(AND);
          break;
        case MOD:
          jj_consume_token(MOD);
          break;
        default:
          jj_la1[37] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
        jjtn000.operador = token.image;
        {if (true) return token.kind;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("OperadorMultiplicativo");
    }
  }

//************************//
  final public int OperadorRelacional() throws ParseException {
    trace_call("OperadorRelacional");
    try {
                          /*@bgen(jjtree) OperadorRelacional */
  ASTOperadorRelacional jjtn000 = new ASTOperadorRelacional(JJTOPERADORRELACIONAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQ:
          jj_consume_token(EQ);
          break;
        case LE:
          jj_consume_token(LE);
          break;
        case GT:
          jj_consume_token(GT);
          break;
        case LT:
          jj_consume_token(LT);
          break;
        case GE:
          jj_consume_token(GE);
          break;
        case NE:
          jj_consume_token(NE);
          break;
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.operador = token.image;
    {if (true) return token.kind;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("OperadorRelacional");
    }
  }

//***********//
  final public int SignoTermino() throws ParseException {
    trace_call("SignoTermino");
    try {
 /*@bgen(jjtree) SignoTermino */
 ASTSignoTermino jjtn000 = new ASTSignoTermino(JJTSIGNOTERMINO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
int tipo;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          t = jj_consume_token(PLUS);
          break;
        case MINUS:
          t = jj_consume_token(MINUS);
          break;
        default:
          jj_la1[39] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        tipo = Termino();
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   jjtn000.jjtSetLastToken(getToken(0));
   jjtn000.signo = t.image;
   {if (true) return tipo;}
      } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
      } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtn000.jjtSetLastToken(getToken(0));
   }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SignoTermino");
    }
  }

//***************//
  final public int Constante() throws ParseException {
    trace_call("Constante");
    try {
 Token t;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
    ASTConstanteInt jjtn001 = new ASTConstanteInt(JJTCONSTANTEINT);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtn001.jjtSetFirstToken(getToken(1));
        try {
          t = jj_consume_token(INTEGER_LITERAL);
                           jjtree.closeNodeScope(jjtn001, true);
                           jjtc001 = false;
                           jjtn001.jjtSetLastToken(getToken(0));
                          jjtn001.valor= Integer.parseInt(t.image);{if (true) return INTEGER;}
        } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      jjtn001.jjtSetLastToken(getToken(0));
    }
        }
        break;
      case STRING_LITERAL:
    ASTConstanteStr jjtn002 = new ASTConstanteStr(JJTCONSTANTESTR);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtn002.jjtSetFirstToken(getToken(1));
        try {
          t = jj_consume_token(STRING_LITERAL);
                          jjtree.closeNodeScope(jjtn002, true);
                          jjtc002 = false;
                          jjtn002.jjtSetLastToken(getToken(0));
                         jjtn002.valor= t.image;{if (true) return STRING;}
        } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
      jjtn002.jjtSetLastToken(getToken(0));
    }
        }
        break;
      case TRUE:
    ASTConstanteBoolTrue jjtn003 = new ASTConstanteBoolTrue(JJTCONSTANTEBOOLTRUE);
    boolean jjtc003 = true;
    jjtree.openNodeScope(jjtn003);
    jjtn003.jjtSetFirstToken(getToken(1));
        try {
          t = jj_consume_token(TRUE);
                  jjtree.closeNodeScope(jjtn003, true);
                  jjtc003 = false;
                  jjtn003.jjtSetLastToken(getToken(0));
                 {if (true) return BOOLEAN;}
        } finally {
    if (jjtc003) {
      jjtree.closeNodeScope(jjtn003, true);
      jjtn003.jjtSetLastToken(getToken(0));
    }
        }
        break;
      case FALSE:
    ASTConstanteBoolFalse jjtn004 = new ASTConstanteBoolFalse(JJTCONSTANTEBOOLFALSE);
    boolean jjtc004 = true;
    jjtree.openNodeScope(jjtn004);
    jjtn004.jjtSetFirstToken(getToken(1));
        try {
          t = jj_consume_token(FALSE);
                   jjtree.closeNodeScope(jjtn004, true);
                   jjtc004 = false;
                   jjtn004.jjtSetLastToken(getToken(0));
                  {if (true) return BOOLEAN;}
        } finally {
    if (jjtc004) {
      jjtree.closeNodeScope(jjtn004, true);
      jjtn004.jjtSetLastToken(getToken(0));
    }
        }
        break;
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Constante");
    }
  }

//************************//
  final public void SentenciaCompuesta() throws ParseException {
    trace_call("SentenciaCompuesta");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
        Seleccion();
        break;
      case WHILE:
        IteracionCondicional();
        break;
      case REPEAT:
        IteracionIncondicional();
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("SentenciaCompuesta");
    }
  }

//***************//
  final public void Seleccion() throws ParseException {
    trace_call("Seleccion");
    try {
 /*@bgen(jjtree) Seleccion */
 ASTSeleccion jjtn000 = new ASTSeleccion(JJTSELECCION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(IF);
        tipo = Expresion();
                           verificarTipos(token,tipo,BOOLEAN);
        Bloque();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ELSE:
          jj_consume_token(ELSE);
          Bloque();
          break;
        default:
          jj_la1[42] = jj_gen;
          ;
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("Seleccion");
    }
  }

  final public void Bloque() throws ParseException {
    trace_call("Bloque");
    try {
               /*@bgen(jjtree) Bloque */
  ASTBloque jjtn000 = new ASTBloque(JJTBLOQUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case WHILE:
        case REPEAT:
        case START:
        case MOVE:
        case RIGHT:
        case TAKEFLOWOR:
        case TAKEPAPER:
        case PUTFLOWER:
        case PUTPAPER:
        case MESSAGE:
        case READ:
        case POSITION:
        case THREAD_START:
        case SEMAPHORE_INIT:
        case SIGNAL:
        case WAIT:
        case IDENTIFIER:
          Sentencia();
          break;
        case BEGIN:
          Cuerpo();
          break;
        default:
          jj_la1[43] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("Bloque");
    }
  }

//**************************//
  final public void IteracionCondicional() throws ParseException {
    trace_call("IteracionCondicional");
    try {
 /*@bgen(jjtree) IteracionCondicional */
 ASTIteracionCondicional jjtn000 = new ASTIteracionCondicional(JJTITERACIONCONDICIONAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(WHILE);
        tipo = Expresion();
                             verificarTipos(token,tipo,BOOLEAN);
        Bloque();
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("IteracionCondicional");
    }
  }

//****************************//
  final public void IteracionIncondicional() throws ParseException {
    trace_call("IteracionIncondicional");
    try {
 /*@bgen(jjtree) IteracionIncondicional */
 ASTIteracionIncondicional jjtn000 = new ASTIteracionIncondicional(JJTITERACIONINCONDICIONAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(REPEAT);
        tipo = Expresion();
                               verificarTipos(token,tipo,INTEGER);
        Bloque();
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("IteracionIncondicional");
    }
  }

//****************//
  final public void Invocacion() throws ParseException {
    trace_call("Invocacion");
    try {
      if (jj_2_5(2)) {
        ProcedimientoUsuarioHilo();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ProcedimientoUsuario();
          break;
        case MESSAGE:
        case READ:
        case POSITION:
        case SEMAPHORE_INIT:
        case SIGNAL:
        case WAIT:
          ProcedimientoPrimitivo();
          break;
        default:
          jj_la1[44] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
      trace_return("Invocacion");
    }
  }

//------------------ algo similar deberia crearse el llamado a una funcion
  final public void ProcedimientoUsuario() throws ParseException {
    trace_call("ProcedimientoUsuario");
    try {
 /*@bgen(jjtree) ProcedimientoUsuario */
 ASTProcedimientoUsuario jjtn000 = new ASTProcedimientoUsuario(JJTPROCEDIMIENTOUSUARIO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token identificador;String nombre;int tipo;int orden=0;int kind;
      try {
        identificador = jj_consume_token(IDENTIFIER);
                  verificarSubprograma(identificador);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          if (jj_2_6(2147483647)) {
            tipo = Identificador();
                                  kind=OUTPUT;
                                  jjtn000.addNombreParametrosReales(token.image);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case TRUE:
            case FALSE:
            case POSAV:
            case POSCA:
            case HAYFLORENLAESQUINA:
            case HAYFLORENLABOLSA:
            case HAYPAPELENLAESQUINA:
            case HAYPAPELENLABOLSA:
            case HAYOBSTACULO:
            case HAYROBOT:
            case RANDOM:
            case LENGTH:
            case SUBSTRING:
            case NUMBERTOTEXT:
            case TEXTTONUMBER:
            case LOGICTOTEXT:
            case LOWERCASE:
            case UPPERCASE:
            case TRIM:
            case REPLACE:
            case STARTSWITH:
            case ENDSWITH:
            case INDEXOF:
            case SQRT:
            case POW:
            case MAX:
            case SIN:
            case COS:
            case TAN:
            case LOG:
            case RANDOMLET:
            case INTEGER_LITERAL:
            case STRING_LITERAL:
            case IDENTIFIER:
            case LPAREN:
            case NOT:
            case PLUS:
            case MINUS:
              tipo = Expresion();
                                          kind=INPUT;
                                          jjtn000.addNombreParametrosReales(null);
              break;
            default:
              jj_la1[45] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
                     verificarParametroSubprograma(identificador,tipo,kind,orden++);
          label_11:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[46] = jj_gen;
              break label_11;
            }
            jj_consume_token(COMMA);
            if (jj_2_7(2147483647)) {
              tipo = Identificador();
                                  kind=OUTPUT;
                                  jjtn000.addNombreParametrosReales(token.image);
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case TRUE:
              case FALSE:
              case POSAV:
              case POSCA:
              case HAYFLORENLAESQUINA:
              case HAYFLORENLABOLSA:
              case HAYPAPELENLAESQUINA:
              case HAYPAPELENLABOLSA:
              case HAYOBSTACULO:
              case HAYROBOT:
              case RANDOM:
              case LENGTH:
              case SUBSTRING:
              case NUMBERTOTEXT:
              case TEXTTONUMBER:
              case LOGICTOTEXT:
              case LOWERCASE:
              case UPPERCASE:
              case TRIM:
              case REPLACE:
              case STARTSWITH:
              case ENDSWITH:
              case INDEXOF:
              case SQRT:
              case POW:
              case MAX:
              case SIN:
              case COS:
              case TAN:
              case LOG:
              case RANDOMLET:
              case INTEGER_LITERAL:
              case STRING_LITERAL:
              case IDENTIFIER:
              case LPAREN:
              case NOT:
              case PLUS:
              case MINUS:
                tipo = Expresion();
                                          kind=INPUT;
                                          jjtn000.addNombreParametrosReales(null);
                break;
              default:
                jj_la1[47] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
                     verificarParametroSubprograma(identificador,tipo,kind,orden++);
          }
          jj_consume_token(RPAREN);
          break;
        default:
          jj_la1[48] = jj_gen;
          ;
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
          //como los parametros son opcionales en la definicion es necesario reconocer la cantidad
          verificarCantidadParametrosSubprograma(identificador, orden);

          //nombre del procedimiento
          jjtn000.nombre=identificador.image;
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    } finally {
      trace_return("ProcedimientoUsuario");
    }
  }

//******************//
  final public void ProcedimientoUsuarioHilo() throws ParseException {
    trace_call("ProcedimientoUsuarioHilo");
    try {
 /*@bgen(jjtree) ProcedimientoUsuarioHilo */
 ASTProcedimientoUsuarioHilo jjtn000 = new ASTProcedimientoUsuarioHilo(JJTPROCEDIMIENTOUSUARIOHILO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token identificador;String nombre;int tipo;int orden=0;
      try {
        jj_consume_token(THREAD_START);
        identificador = jj_consume_token(IDENTIFIER);
                  //nombre=t.image;
                  verificarHilo(identificador);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          tipo = Expresion();
                                 // jjtThis.add(null);
                      verificarParametroHilo(identificador,tipo,orden++);
          label_12:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[49] = jj_gen;
              break label_12;
            }
            jj_consume_token(COMMA);
            tipo = Expresion();
                                  //jjtThis.add(null);
                          verificarParametroHilo(identificador,tipo,orden++);
          }
          jj_consume_token(RPAREN);
          break;
        default:
          jj_la1[50] = jj_gen;
          ;
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
          //como los parametros son opcionales en la definicion es necesario reconocer la cantidad
          verificarCantidadParametrosHilo(identificador, orden);
      //nombre del hilo/robot
      jjtn000.nombre=identificador.image;
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    } finally {
      trace_return("ProcedimientoUsuarioHilo");
    }
  }

//**********************//
  final public void ProcedimientoPrimitivo() throws ParseException {
    trace_call("ProcedimientoPrimitivo");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MESSAGE:
        Informar();
        break;
      case POSITION:
        Pos();
        break;
      case READ:
        Leer();
        break;
      case SEMAPHORE_INIT:
        IniciarSemaforo();
        break;
      case SIGNAL:
        Senal();
        break;
      case WAIT:
        Esperar();
        break;
      default:
        jj_la1[51] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("ProcedimientoPrimitivo");
    }
  }

//***************//
  final public void Informar() throws ParseException {
    trace_call("Informar");
    try {
                 /*@bgen(jjtree) Informar */
  ASTInformar jjtn000 = new ASTInformar(JJTINFORMAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
      try {
        jj_consume_token(MESSAGE);
        jj_consume_token(LPAREN);
        Expresion();
        label_13:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[52] = jj_gen;
            break label_13;
          }
          jj_consume_token(COMMA);
          Expresion();
        }
        jj_consume_token(RPAREN);
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("Informar");
    }
  }

//**********//
  final public void Leer() throws ParseException {
    trace_call("Leer");
    try {
 /*@bgen(jjtree) Leer */
 ASTLeer jjtn000 = new ASTLeer(JJTLEER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(READ);
        jj_consume_token(LPAREN);
        tipo = Identificador();
                          verificarTipos(token,tipo,tipo,EQ);
        jj_consume_token(RPAREN);
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
      }
    } finally {
      trace_return("Leer");
    }
  }

//*****************//
  final public void Pos() throws ParseException {
    trace_call("Pos");
    try {
 /*@bgen(jjtree) Pri_Pos */
 ASTPri_Pos jjtn000 = new ASTPri_Pos(JJTPRI_POS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(POSITION);
        jj_consume_token(LPAREN);
        tipo = Expresion();
                                  verificarTipos(token,tipo,INTEGER);
        jj_consume_token(COMMA);
        tipo = Expresion();
                                  verificarTipos(token,tipo,INTEGER);
        jj_consume_token(RPAREN);
      } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
      } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtn000.jjtSetLastToken(getToken(0));
   }
      }
    } finally {
      trace_return("Pos");
    }
  }

//****************************************//
  final public void IniciarSemaforo() throws ParseException {
    trace_call("IniciarSemaforo");
    try {
 /*@bgen(jjtree) Pri_IniciarSemaforo */
 ASTPri_IniciarSemaforo jjtn000 = new ASTPri_IniciarSemaforo(JJTPRI_INICIARSEMAFORO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(SEMAPHORE_INIT);
        jj_consume_token(LPAREN);
        tipo = Identificador();
                                      verificarTipos(token,tipo,SEMAPHORE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          tipo = Expresion();
                                             verificarTipos(token,tipo,INTEGER);
          break;
        default:
          jj_la1[53] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    } finally {
      trace_return("IniciarSemaforo");
    }
  }

//*********************//
  final public void Senal() throws ParseException {
    trace_call("Senal");
    try {
 /*@bgen(jjtree) Pri_PS */
 ASTPri_PS jjtn000 = new ASTPri_PS(JJTPRI_PS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(SIGNAL);
        jj_consume_token(LPAREN);
        tipo = Identificador();
                                      verificarTipos(token,tipo,SEMAPHORE);
        jj_consume_token(RPAREN);
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    } finally {
      trace_return("Senal");
    }
  }

//*********************//
  final public void Esperar() throws ParseException {
    trace_call("Esperar");
    try {
 /*@bgen(jjtree) Pri_PE */
 ASTPri_PE jjtn000 = new ASTPri_PE(JJTPRI_PE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));int tipo;
      try {
        jj_consume_token(WAIT);
        jj_consume_token(LPAREN);
        tipo = Identificador();
                                      verificarTipos(token,tipo,SEMAPHORE);
        jj_consume_token(RPAREN);
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
      }
    } finally {
      trace_return("Esperar");
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_3R_17() {
    if (jj_scan_token(THREAD_START)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_15()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) return true;
    }
    return false;
  }

  private boolean jj_3R_14() {
    if (jj_3R_15()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_15()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) return true;
    }
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_15()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) return true;
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_14()) return true;
    return false;
  }

  private boolean jj_3R_16() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_16()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_15()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) return true;
    }
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_15() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[54];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x200000,0x4000,0x0,0x200000,0xf6800000,0x0,0x0,0x200000,0x0,0x18000,0x18000,0x0,0x200000,0x0,0x200000,0xf6800000,0x0,0x1c0000,0x0,0x700,0xf6800000,0xf0000000,0x0,0x1800,0x0,0x1800,0x1800,0x0,0x1800,0x0,0x0,0x0,0x1800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1800,0x6800000,0x1000000,0xf6c00000,0x0,0x1800,0x0,0x1800,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x4000,0x0,0x713807,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x713807,0x0,0x0,0x0,0xc0000,0x713807,0x7,0x713800,0xff8007f8,0x0,0xff8007f8,0xff8007f8,0x0,0xff8007f8,0x0,0x0,0x0,0xff8007f8,0xff800400,0x0,0x3f8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x713807,0x703800,0xff8007f8,0x0,0xff8007f8,0x0,0x0,0x0,0x703800,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x4000,0x0,0x8000,0x0,0x80000,0x0,0x0,0x8000,0x0,0x8000,0x0,0x4000,0x80000,0x0,0x4000,0x0,0x4000,0x0,0x4000,0xffff,0x200000,0xffff,0xffff,0x3f000000,0xffff,0x40000000,0x80000000,0x4000,0xffff,0xfff,0x8000,0x0,0x40000000,0x80000000,0x3f000000,0x0,0x3000,0x0,0x0,0x4000,0x4000,0xffff,0x200000,0xffff,0x8000,0x200000,0x8000,0x0,0x200000,0x200000,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x7,0x7,0x0,0x7,0x6,0x38,0x0,0x1,0x0,0x0,0x0,0x6,0x38,0x0,0x6,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[7];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 54; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 54; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 54; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 54; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 54; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 54; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[102];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 54; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 102; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 7; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
